C51 COMPILER V9.54   MAIN                                                                  05/31/2025 17:05:19 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keil5\C51\BIN\C51.EXE main\main.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\main;.\system;.\bsp\be
                    -ep;.\bsp\eeprom;.\bsp\oled;.\bsp\encoder;.\bsp\timer0) DEBUG OBJECTEXTEND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Ob
                    -jects\main.obj)

line level    source

   1          #include "config.h"
   2          #include "timer0.h"
   3          #include "uart.h"
   4          #include "delay.h"
   5          
   6          #include "encoder.h"
   7          #include "beep.h"
   8          #include "oled.h"
   9          #include "bmp.h"
  10          
  11          uint8_t xdata time_buf_main[16];// 主界面时间显示缓冲
  12          volatile bit beep_active = 0; // 蜂鸣器开关状态
  13          volatile bit beep_on = 0;
  14          unsigned long t0 = 0, time_update = 0;
  15          void Handle_Buzzer(bit on);
  16          volatile bit WDT_FLAGE = 1; // 看门狗标志位
  17          #define AUTO_SLEEP_TIMEOUT_MS 30000
  18          volatile unsigned long last_user_tick = 0; // 记录上次用户操作时间
  19          
  20          void gpio_init(void)
  21          {
  22   1          // P30 - 编码器按下按钮输入
  23   1          P3M1 |= (1 << 0);  // 清除 P3.0 的 M1 位
  24   1          P3M0 &= ~(1 << 0); // 清除 P3.0 的 M0 位
  25   1      
  26   1          // P31 - 蜂鸣器控制输出
  27   1          P3M1 &= ~(1 << 1); // 清除 P3.1 的 M1 位
  28   1          P3M0 |= (1 << 1);  // 设置 P3.1 的 M0 位 -> 推挽输出
  29   1      
  30   1          // P32 - I2C SDA
  31   1          P3M1 |= (1 << 2); // 设置 P3.2 的 M1 位
  32   1          P3M0 |= (1 << 2); // 设置 P3.2 的 M0 位 -> 开漏输出（I2C 要求）
  33   1      
  34   1          // P33 - I2C SCL
  35   1          P3M1 |= (1 << 3); // 设置 P3.3 的 M1 位
  36   1          P3M0 |= (1 << 3); // 设置 P3.3 的 M0 位 -> 开漏输出（I2C 要求）
  37   1      
  38   1          // P54 - 编码器 A 相输入
  39   1          P5M1 &= ~(1 << 4); // 清除 P5.4 的 M1 位
  40   1          P5M0 &= ~(1 << 4); // 清除 P5.4 的 M0 位 -> 准双向口（输入）
  41   1      
  42   1          // P55 - 编码器 B 相输入
  43   1          P5M1 &= ~(1 << 5); // 清除 P5.5 的 M1 位
  44   1          P5M0 &= ~(1 << 5); // 清除 P5.5 的 M0 位 -> 准双向口（输入）
  45   1      }
  46          //状态切换
  47          void UpdateMode(void)
  48          {
  49   1      
  50   1          current_mode = (current_mode == SET_MODE) ? COUNTDOWN_MODE : SET_MODE;
  51   1          last_user_tick = getsystick();
  52   1          OLED_Clear();
  53   1          PWM_Set(1200, 50);
C51 COMPILER V9.54   MAIN                                                                  05/31/2025 17:05:19 PAGE 2   

  54   1          PWM_ON();
  55   1          Delay_ms(100);
  56   1          PWM_OFF();
  57   1          beep_on = 0;
  58   1          sprintf(time_buf_main, "%02d:%02d:%02d", time_h, time_m, time_s);
  59   1          OLED_ShowString(0, 2, time_buf_main, 32); // 字号32，居中显示
  60   1      }
  61          // 按键切换模式并控制蜂鸣器
  62          void Handle_KeyPress()
  63          {
  64   1          static key_mode = 0; // 0: 未按下, 1: 短按, 2: 长按
  65   1          static bit key_last = 0;
  66   1          static unsigned long key_down_time = 0;
  67   1      
  68   1          if (KEY == 1)
  69   1          {
  70   2              if (!key_last)
  71   2              {
  72   3                  key_last = 1;
  73   3                  key_down_time = getsystick();
  74   3              }
  75   2              else
  76   2              {
  77   3                  unsigned long duration = getsystick() - key_down_time;
  78   3                  if (duration >= 1400)
  79   3                  {
  80   4                      key_mode = 2;
  81   4                  }
  82   3                  if (duration >= 100 && duration <= 1400)
  83   3                  {
  84   4                      key_mode = 1;
  85   4                  }
  86   3              }
  87   2          }
  88   1          else // KEY == 0，按键松开
  89   1          {
  90   2              if (key_last) // 上一轮是按下状态，现在松开
  91   2              {
  92   3                  if (key_mode == 1) // 短按
  93   3                  {
  94   4                      UpdateMode();
  95   4                  }
  96   3                  else if (key_mode == 2) // 长按
  97   3                  {
  98   4                      PWM_Set(500, 50);
  99   4                      PWM_ON();
 100   4                      Delay_ms(50);
 101   4                      PWM_OFF();
 102   4                      WDT_FLAGE = 0;
 103   4                  }
 104   3      
 105   3                  // 重置所有状态
 106   3                  key_mode = 0;
 107   3                  key_last = 0;
 108   3              }
 109   2          }
 110   1      }
 111          
 112          // 旋转编码器设置时间
 113          void Handle_Encoder()
 114          {
 115   1          if (sampling_ready)
C51 COMPILER V9.54   MAIN                                                                  05/31/2025 17:05:19 PAGE 3   

 116   1          {
 117   2              int sum = 0;
 118   2              char i = 0;
 119   2              for (i = 0; i < SAMPLE_COUNT; i++)
 120   2                  sum += encoder_samples[i];
 121   2      
 122   2              if (sum > 0)
 123   2                  encoder_step = +1;
 124   2              else if (sum < 0)
 125   2                  encoder_step = -1;
 126   2              else
 127   2                  encoder_step = 0; // 干扰忽略
 128   2      
 129   2              sampling_ready = 0;
 130   2          }
 131   1          if (current_mode == SET_MODE && encoder_step != 0)
 132   1          {
 133   2              last_user_tick = getsystick();
 134   2              PWM_Set(1400, 50);
 135   2              PWM_ON();
 136   2              Delay_ms(50);
 137   2              PWM_OFF();
 138   2              UpdateTime(encoder_step * 20);
 139   2              encoder_step = 0;
 140   2          }
 141   1      }
 142          
 143          // 倒计时逻辑
 144          void Handle_Countdown()
 145          {
 146   1          if (current_mode == COUNTDOWN_MODE && getsystick() - time_update >= 1000)
 147   1          {
 148   2              time_update = getsystick();
 149   2              UpdateTime(-1);
 150   2              if (time_h == 0 && time_m == 0 && time_s == 1 && !beep_active)
 151   2              {
 152   3                  beep_on = 1;
 153   3              }
 154   2          }
 155   1      }
 156          
 157          const uint16_t nokia_melody[] = {
 158              1319, 1175, 1047, 1175, 1319, 1319, 1319,
 159              1175, 1175, 1175, 1319, 1568, 1568};
 160          
 161          // 蜂鸣器控制
 162          void Handle_Buzzer(bit on)
 163          {
 164   1          static unsigned long t0 = 0;
 165   1          unsigned long elapsed;
 166   1      
 167   1          if (on)
 168   1          {
 169   2              if (!beep_active)
 170   2              {
 171   3                  beep_active = 1;
 172   3                  t0 = getsystick(); // 初次开启蜂鸣器，记录起始时间
 173   3              }
 174   2      
 175   2              elapsed = getsystick() - t0;
 176   2      
 177   2              if (elapsed < 200)
C51 COMPILER V9.54   MAIN                                                                  05/31/2025 17:05:19 PAGE 4   

 178   2                  PWM_Set(nokia_melody[0], 50);
 179   2              else if (elapsed < 400)
 180   2                  PWM_Set(nokia_melody[1], 50);
 181   2              else if (elapsed < 600)
 182   2                  PWM_Set(nokia_melody[2], 50);
 183   2              else if (elapsed < 800)
 184   2                  PWM_Set(nokia_melody[3], 50);
 185   2              else if (elapsed < 1000)
 186   2                  PWM_Set(nokia_melody[4], 50);
 187   2              else if (elapsed < 1200)
 188   2                  PWM_Set(nokia_melody[5], 50);
 189   2              else if (elapsed < 1400)
 190   2                  PWM_Set(nokia_melody[6], 50);
 191   2              else if (elapsed < 1800)
 192   2                  PWM_Set(nokia_melody[7], 50);
 193   2              else if (elapsed < 2000)
 194   2                  PWM_Set(nokia_melody[8], 50);
 195   2              else if (elapsed < 2200)
 196   2                  PWM_Set(nokia_melody[9], 50);
 197   2              else if (elapsed < 2400)
 198   2                  PWM_Set(nokia_melody[10], 50);
 199   2              else if (elapsed < 2600)
 200   2                  PWM_Set(nokia_melody[11], 50);
 201   2              else if (elapsed < 2800)
 202   2                  PWM_Set(nokia_melody[12], 50);
 203   2      
 204   2              else
 205   2                  t0 = getsystick(); // 重置时间，重新开始一轮节奏
 206   2      
 207   2              PWM_ON(); // 确保始终保持开启
 208   2          }
 209   1          else
 210   1          {
 211   2              PWM_OFF();
 212   2              beep_active = 0;
 213   2              t0 = getsystick(); // 也可清零计时，防止脉冲残留
 214   2          }
 215   1      }
 216          
 217          void Check_Inactivity_Sleep(void)
 218          {
 219   1          if (current_mode != COUNTDOWN_MODE) // 倒计时模式不自动关机
 220   1          {
 221   2              if (getsystick() - last_user_tick >= AUTO_SLEEP_TIMEOUT_MS)
 222   2              {
 223   3                  OLED_Clear(); // 可选：关屏
 224   3                  PWM_OFF();    // 可选：关闭蜂鸣器
 225   3      
 226   3                  PCON |= 0x02; // 设置掉电位
 227   3                  _nop_();      // 掉电后立即进入中断
 228   3                  _nop_();
 229   3      
 230   3                  gpio_init();
 231   3                  BEEP = 0;
 232   3                  encoder_init();
 233   3                  Timer0_Init();
 234   3                  OLED_Init();         // 初始化OLED
 235   3                  OLED_ColorTurn(0);   // 0正常显示，1 反色显示
 236   3                  OLED_DisplayTurn(0); // 0正常显示 1 屏幕翻转显示
 237   3                  PWM_Set(1200, 50);
 238   3                  last_user_tick = getsystick(); // 防止刚唤醒又进入掉电
 239   3                  EA = 1;                        // 唤醒后重新开启中断
C51 COMPILER V9.54   MAIN                                                                  05/31/2025 17:05:19 PAGE 5   

 240   3              }
 241   2          }
 242   1      }
 243          #define LVD3V0 0x03 // LVD@3.0V
 244          #define LVDF 0x20
 245          
 246          void main(void)
 247          {
 248   1      
 249   1          gpio_init();
 250   1          BEEP = 0;
 251   1          encoder_init();
 252   1          Timer0_Init();
 253   1          OLED_Init();         // 初始化OLED
 254   1          OLED_ColorTurn(0);   // 0正常显示，1 反色显示
 255   1          OLED_DisplayTurn(0); // 0正常显示 1 屏幕翻转显示
 256   1          sprintf(time_buf_main, "%02d:%02d:%02d", time_h, time_m, time_s);
 257   1          OLED_ShowString(0, 2, time_buf_main, 32); // 字号32，居中显示
 258   1          PWM_Set(1200, 50);
 259   1          WDT_CONTR = 0x24;//使能看门狗,溢出时间约为 1s
 260   1          WDT_FLAGE = 1; // 清除看门狗标志位
 261   1          RSTCFG = LVD3V0; // 设置 LVD 阈值为 3.0V，不使能复位
 262   1          ELVD = 1;        // 开启 LVD 中断
 263   1          EA = 1;
 264   1          time_update = getsystick();
 265   1          while (1)
 266   1          {
 267   2              if(WDT_FLAGE) // 检查看门狗标志
 268   2              {
 269   3                  WDT_CONTR |= 0x10; //清看门狗
 270   3              }
 271   2              Handle_KeyPress();
 272   2              Handle_Encoder();
 273   2              Handle_Countdown();
 274   2              Handle_Buzzer(beep_on);
 275   2              Check_Inactivity_Sleep();
 276   2              ShowTime();
 277   2          }
 278   1      }
 279          
 280          void Lvd_Isr() interrupt 6
 281          {
 282   1          PCON &= ~LVDF; // 清中断标志
 283   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1514    ----
   CONSTANT SIZE    =   1039    ----
   XDATA SIZE       =     64      11
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
